<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>Lab 8: Procedural Generation</title>
		<style>
			body { margin: 0; }
			canvas { display: block; }
		</style>
	</head>
	<body>
		<script src="../three.js-master/build/three.js"></script>
		<script src="../three.js-master/examples/js/loaders/OBJLoader.js"></script>
		<script>
			var loader = new THREE.OBJLoader();
			function loadModel(url, callback) {
				var model;
				loader.load(
					url,
					callback,
					function(xhr) {
						console.log((xhr.loaded / xhr.total * 100)+"% loaded");
					},
					function(error) {
						console.log("Error!");
					}
				);
			}
		</script>
		<script>
			// this function loads the context for the canvas
			function initContext(canvasID, contextType) {
				var canvas = document.createElement('canvas');
				var context = canvas.getContext(contextType);
				return context;
			}

			// this loads the image, but mainly, when the image loads, it calls readImage()
			function loadImage(imageSource, context) {
				var imageObj = new Image();
				imageObj.onload = function() {
					context.drawImage(imageObj, 0, 0);
					// get image data samples each pixel from the first two  x,y coordinates 
					// to the latter two
					var imageData = context.getImageData(0,0,planeSize,planeSize);
					readImage(imageData);
				};
				imageObj.src = imageSource;
			}

			// since this method is only called when the image is loaded, 
			//we know we have the image pixel data
			function readImage(imageData) {
				// since the imageData.data looks like this [r0, g0, b0, a0, r1, g1, b1, a1â€¦]
				// and since our noise is greyscale (rgb are all the same number)
				// we only need every fourth number to collect all the red values
				var noiseData = [];
				var minVal = 255;
				var maxVal = 0;
				for(var i = 0; i < imageData.data.length; i+=4) {
					noiseData.push(imageData.data[i]); // just saving red component
					if(imageData.data[i] < minVal) minVal = imageData.data[i];
					if(imageData.data[i] > maxVal) maxVal = imageData.data[i];
				}

				// now noiseData is a list of semi-random values from 0 to 255
				// building generation code will go here:
				var buildingPositions = [];
				for(var r = -planeSize / 2; r < planeSize / 2; r++) {
					buildingPositions[r] = [];
					for(var c = -planeSize / 2; c < planeSize / 2; c++) {
						var geometry = new THREE.PlaneGeometry(1, 1, 1, 1);
						geometry.rotateX(-Math.PI / 2);
						let skewMatrix = new THREE.Matrix4();
						let s = 0.125;
						skewMatrix.set(
							1, 0, s, 0,
							0, 1, 0, 0,
							0, 0, 1, 0,
							0, 0, 0, 1
						);
						geometry.applyMatrix4(skewMatrix);
						var material = new THREE.MeshPhongMaterial({ color:0x00ff00 });
						var grass = new THREE.Mesh(geometry, material);
						grass.scale.x = 0.9;
						grass.scale.z = 0.9;
						buildingPositions[r][c] = [
							r + ((c * s) % 1) + grass.scale.x / 2,
							planeCenter.z + c + grass.scale.z / 2
						];
						grass.position.x = buildingPositions[r][c][0];
						grass.position.z = buildingPositions[r][c][1];
						grass.position.y = planeCenter.y + 0.001;
						scene.add(grass);
					}
				}
				for(var r = -planeSize / 2; r < planeSize / 2; r++) {
					for(var c = -planeSize / 2; c < planeSize / 2; c++) {
						//var geometry = new THREE.BoxGeometry();
						var geometry = building1;
						var material = new THREE.MeshPhongMaterial({ color:0xaaaaaa });
						var cube = new THREE.Mesh(geometry, material);
						// This index should grab the color at row r and column c
						let noiseIndex = Math.floor(noiseData.length * (r + (planeSize / 2)) / planeSize) + Math.floor(Math.sqrt(noiseData.length) * (c + (planeSize / 2)) / planeSize);
						// Scale the value
						//cube.scale.y = 2 * (5 + ((noiseData[noiseIndex] - minVal) % 64)) / 64;
						cube.scale.y = 0.2;
						cube.scale.x = 0.2;
						cube.scale.z = 0.2;
						cube.position.x = buildingPositions[r][c][0];
						cube.position.z = buildingPositions[r][c][1];
						cube.position.y = planeCenter.y;
						scene.add(cube);
					}
				}
			}


			// setup the scene
			var scene = new THREE.Scene();
			var camera = new THREE.PerspectiveCamera(75,window.innerWidth/window.innerHeight, 0.1, 1000);
			var renderer = new THREE.WebGLRenderer();
			renderer.setSize(window.innerWidth, window.innerHeight);
			document.body.appendChild(renderer.domElement);
			camera.position.z = 10;
			camera.position.y = 3;
			camera.lookAt(0,0,0);

			// PlaneGeometry
			const mat = new THREE.MeshPhongMaterial({color:0x4f4f4f, shininess:100, side:THREE.DoubleSide});
			var planeSize = 8;
			var p = new THREE.PlaneGeometry(planeSize, planeSize, 100, 100);
			var plane = new THREE.Mesh(p, mat);
			var planeCenter = new THREE.Vector3(0,-parseInt(planeSize/4),-planeSize/2);
			plane.position.z = planeCenter.z;
			plane.position.y = planeCenter.y;
			plane.rotation.x = Math.PI/2;
			scene.add(plane);

			// add the lights all around the city
			for(var a = 270; a < 270 * 2; a+=100) {
				var light = new THREE.PointLight(0xffffff, 1, planeSize * 1.5);
				light.position.set(
					planeSize * Math.cos(THREE.MathUtils.degToRad(a)),
					planeCenter.y + planeSize/2,
					planeCenter.z + planeSize * Math.sin(THREE.MathUtils.degToRad(a)));
				scene.add(light);
			}

			//make the camera able to rotate around the city 
			//based on the a,d keys
			var angle = THREE.MathUtils.degToRad(270);
			camera.position.x = planeSize * 1.2 * Math.cos(angle);
			camera.position.z = planeCenter.z + planeSize * 1.2 * Math.sin(angle);
			camera.position.y = 4;
			camera.lookAt(0,0,planeCenter.z);
			document.onkeypress =  function(event) {
				var x = event.key;
				if(x == 'a') {
					angle += 0.1;
				} else if (x == 'd') {
					angle -= 0.1;
				}
			camera.position.x = planeSize * 1.2 * Math.cos(angle);
			camera.position.z = planeCenter.z + planeSize * 1.2 * Math.sin(angle);
			camera.lookAt(0,0,planeCenter.z);
			};


			let count = 0;
			let monke;
			let building1;
			loadModel("monke.obj", (object) => { monke = object.children[0].geometry; count++; });
			loadModel("plan_voisin_building_1.obj", (object) => { building1 = object.children[0].geometry; count++; });

			function afterLoadedOBJs() {
				console.log("All OBJs loaded");
				var context = initContext('canvas','2d'); // initialize the canvas
				loadImage('perlin_34_34.jpg',context); // load the perlin image
			}

			function animate() {
				requestAnimationFrame(animate);
				if(count == 2) {
					count = -1;
					afterLoadedOBJs();
				}
				renderer.render(scene, camera);
			}
			animate();
		</script>
	</body>
</html>
