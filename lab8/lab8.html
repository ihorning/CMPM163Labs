<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>Lab 8: Procedural Generation</title>
		<style>
			body { margin: 0; }
			canvas { display: block; }
		</style>
	</head>
	<body>
		<script src="../three.js-master/build/three.js"></script>
		<script src="../three.js-master/examples/js/loaders/OBJLoader.js"></script>
		<script>
			var loader = new THREE.OBJLoader();
			function loadModel(url, callback) {
				var model;
				loader.load(
					url,
					callback,
					function(xhr) {
						console.log((xhr.loaded / xhr.total * 100)+"% loaded");
					},
					function(error) {
						console.log("Error!");
					}
				);
			}
		</script>
		<script>
			// this function loads the context for the canvas
			function initContext(canvasID, contextType) {
				var canvas = document.createElement('canvas');
				var context = canvas.getContext(contextType);
				return context;
			}

			// this loads the image, but mainly, when the image loads, it calls readImage()
			function loadImage(imageSource, context) {
				var imageObj = new Image();
				imageObj.onload = function() {
					context.drawImage(imageObj, 0, 0);
					// get image data samples each pixel from the first two  x,y coordinates 
					// to the latter two
					var imageData = context.getImageData(0,0,planeSize,planeSize);
					readImage(imageData);
				};
				imageObj.src = imageSource;
			}

			// since this method is only called when the image is loaded, 
			//we know we have the image pixel data
			function readImage(imageData) {
				// since the imageData.data looks like this [r0, g0, b0, a0, r1, g1, b1, a1â€¦]
				// and since our noise is greyscale (rgb are all the same number)
				// we only need every fourth number to collect all the red values
				var noiseData = [];
				var minVal = 255;
				var maxVal = 0;
				for(var i = 0; i < imageData.data.length; i+=4) {
					noiseData.push(imageData.data[i]); // just saving red component
					if(imageData.data[i] < minVal) minVal = imageData.data[i];
					if(imageData.data[i] > maxVal) maxVal = imageData.data[i];
				}

				// now noiseData is a list of semi-random values from 0 to 255
				// building generation code will go here:
				var tileInfo = [];
				for(var r = -planeSize / 2; r < planeSize / 2; r++) {
					tileInfo[r] = [];
					for(var c = -planeSize / 2; c < planeSize / 2; c++) {
						// Map index from -planeSize/2 => 0 => planeSize/2  to  1 => 0 => 1  so there is symmetry about the center
						let indexR = noiseData.length * (r < 0 ? (-2 * r) : (2 * r)) / planeSize;
						if(indexR + Math.floor(Math.sqrt(noiseData.length)) >= noiseData.length) indexR -= Math.floor(Math.sqrt(noiseData.length));
						let indexC = Math.sqrt(noiseData.length) * (c < 0 ? (-2 * c) : (2 * c)) / planeSize;
						let noiseIndex = Math.floor(indexR) + Math.floor(indexC);
						if(noiseIndex >= indexR + Math.floor(Math.sqrt(noiseData.length))) noiseIndex--;
						let value = noiseData[noiseIndex] / 255;

						var geometry = new THREE.PlaneGeometry(1, 1, 1, 1);
						geometry.rotateX(-Math.PI / 2);
						let skewMatrix = new THREE.Matrix4();
						let s = 0.2;
						skewMatrix.set(
							1, 0, s, 0,
							0, 1, 0, 0,
							0, 0, 1, 0,
							0, 0, 0, 1
						);
						geometry.applyMatrix4(skewMatrix);

						let tileScale = 0.9;

						tileInfo[r][c] = [
							r + ((c * s) % 1) + tileScale / 2,
							planeCenter.z + c + tileScale / 2,
							value
						];

						if(value < 0.3) {
							tileInfo[r][c][3] = "i2";
						} else if(value < 0.4) {
							tileInfo[r][c][3] = "i1";
						} else if(value < 0.5) {
							tileInfo[r][c][3] = "g1";
						} else if(value < 0.6) {
							tileInfo[r][c][3] = "b2";
						} else if(value < 0.7) {
							tileInfo[r][c][3] = "t";
						} else {
							tileInfo[r][c][3] = "b1";
						}

						let material;
						if(tileInfo[r][c][3] != "i1" && tileInfo[r][c][3] != "i2" && tileInfo[r][c][3] != "t") {
							material = new THREE.MeshPhongMaterial({ color:0x22bb22 });
						} else {
							material = new THREE.MeshPhongMaterial({ color:0xaaaaaa });
						}

						var grass = new THREE.Mesh(geometry, material);
						grass.scale.x = tileScale;
						grass.scale.z = tileScale;

						grass.position.x = tileInfo[r][c][0];
						grass.position.z = tileInfo[r][c][1];
						grass.position.y = planeCenter.y + 0.001;
						scene.add(grass);
					}
				}
				for(var r = -planeSize / 2; r < planeSize / 2; r++) {
					for(var c = -planeSize / 2; c < planeSize / 2; c++) {
						var geometry = geometryDict[tileInfo[r][c][3]];
						if(tileInfo[r][c][3] == "t") {
							geometry = geometry.clone();
							let h = tileInfo[r][c][2] > 0.65 ? 3 : 7;
							geometry.scale(1.25, h, 1.25);
							geometry.translate(0, h / 2, 0);
						}
						var material = new THREE.MeshPhongMaterial({ color: new THREE.Color(tileInfo[r][c][2], tileInfo[r][c][2], tileInfo[r][c][2]) });
						var building = new THREE.Mesh(geometry, material);
						building.scale.y = 0.25;
						building.scale.x = 0.25;
						building.scale.z = 0.25;
						building.position.x = tileInfo[r][c][0];
						building.position.z = tileInfo[r][c][1];
						building.position.y = planeCenter.y;
						scene.add(building);
					}
				}
			}


			// setup the scene
			var scene = new THREE.Scene();
			var camera = new THREE.PerspectiveCamera(75,window.innerWidth/window.innerHeight, 0.1, 1000);
			var renderer = new THREE.WebGLRenderer();
			renderer.setSize(window.innerWidth, window.innerHeight);
			document.body.appendChild(renderer.domElement);
			camera.position.z = 10;
			camera.position.y = 3;
			camera.lookAt(0,0,0);

			// PlaneGeometry
			const mat = new THREE.MeshPhongMaterial({color:0x4f4f4f, shininess:100, side:THREE.DoubleSide});
			var planeSize = 32;
			var p = new THREE.PlaneGeometry(planeSize, planeSize, 100, 100);
			var plane = new THREE.Mesh(p, mat);
			var planeCenter = new THREE.Vector3(0,-parseInt(planeSize/4),-planeSize/2);
			plane.position.z = planeCenter.z;
			plane.position.y = planeCenter.y;
			plane.rotation.x = Math.PI/2;
			scene.add(plane);

			// add the lights all around the city
			for(var a = 270; a < 270 * 2; a+=100) {
				var light = new THREE.PointLight(0xffffff, 1, planeSize * 2);
				light.position.set(
					planeSize * Math.cos(THREE.MathUtils.degToRad(a)),
					planeCenter.y + planeSize/2,
					planeCenter.z + planeSize * Math.sin(THREE.MathUtils.degToRad(a)));
				scene.add(light);
			}

			//make the camera able to rotate around the city 
			//based on the a,d keys
			var angle1 = THREE.MathUtils.degToRad(270);
			var angle2 = 0;
			var zoom = 1;
			let camPos = new THREE.Vector3(
				1.2 * Math.cos(angle1) * Math.cos(angle2),
				0.8 * Math.sin(angle2),
				1.2 * Math.sin(angle1) * Math.cos(angle2)
			);
			camPos.normalize().multiplyScalar(zoom * planeSize);
			camPos.add(new THREE.Vector3(0, 0, planeCenter.z));
			camera.position.set(camPos.x, camPos.y, camPos.z);
			//camera.position.x = planeSize * 1.2 * Math.cos(angle1) * Math.cos(angle2);
			//camera.position.z = planeCenter.z + planeSize * 1.2 * Math.sin(angle1) * Math.cos(angle2);
			//camera.position.y = planeSize * 0.8 * Math.sin(angle2);
			camera.lookAt(0,0,planeCenter.z);
			document.onkeypress =  function(event) {
				var x = event.key;
				if(x == 'a') {
					angle1 += 0.1;
				} else if (x == 'd') {
					angle1 -= 0.1;
				} else if(x == 'w') {
					angle2 += 0.1;
				} else if(x == 's') {
					angle2 -= 0.1;
				} else if(x == 'z') {
					zoom += 0.05;
				} else if(x == 'x') {
					zoom -= 0.05;
				}
				if(angle2 > (Math.PI / 2) - 0.1) angle2 = (Math.PI / 2) - 0.1;
				if(angle2 < 0) angle2 = 0;
				if(zoom < 0.1) zoom = 0.1;
				if(zoom > 1) zoom = 1;
				let camPos = new THREE.Vector3(
					1.2 * Math.cos(angle1) * Math.cos(angle2),
					0.8 * Math.sin(angle2),
					1.2 * Math.sin(angle1) * Math.cos(angle2)
				);
				camPos.normalize().multiplyScalar(zoom * planeSize);
				camPos.add(new THREE.Vector3(0, 0, planeCenter.z));
				camera.position.set(camPos.x, camPos.y, camPos.z);
				camera.lookAt(0,0,planeCenter.z);
			};


			let count = 0;
			let monke;
			let building1, building2, building3;
			let industrial1, industrial2;
			let garden1;
			let tower = new THREE.BoxGeometry(1.25, 1, 1.25);
			let geometryDict;
			loadModel("monke.obj", (object) => { monke = object.children[0].geometry; count++; });
			loadModel("plan_voisin_building_1.obj", (object) => { building1 = object.children[0].geometry; count++; });
			loadModel("plan_voisin_garden_1.obj", (object) => { garden1 = object.children[0].geometry; garden1.scale(0.8, 0.8, 0.8); count++; });
			loadModel("plan_voisin_industrial_1.obj", (object) => { industrial1 = object.children[0].geometry; count++; });

			function afterLoadedOBJs() {
				console.log("All OBJs loaded");
				var context = initContext('canvas','2d'); // initialize the canvas
				loadImage('perlin_34_34.jpg',context); // load the perlin image
				//loadImage('testgradient.jpg',context);
				geometryDict = {
					"b1": building1,
					"b2": building2,
					"i1": industrial1,
					"i2": industrial2,
					"g1": garden1,
					"t": tower
				}
			}

			function animate() {
				requestAnimationFrame(animate);
				if(count == 4) {
					count = -1;
					afterLoadedOBJs();
				}
				renderer.render(scene, camera);
			}
			animate();
		</script>
	</body>
</html>
